import { ethers } from "ethers";
import config from "@/config";
import axios from "axios";

const contractJSON = require('@/abi/Deposit_V1.json') // Vulnerable smartcontract
const provider = new ethers.InfuraWebSocketProvider(config.NETWORK, config.INFURA_API_KEY);
//const provider = new ethers.WebSocketProvider("http://127.0.0.1:8545");
const wallet = ethers.Wallet.fromPhrase(config.MNEMONIC, provider);
const contract = new ethers.Contract(config.CONTRACT_ADDRESS, contractJSON.abi, wallet);
let lastSuspectedReentrancy = "0x0"  // prevent re-firing of reentrancy event


const watchAndPause = async () => {
    try {
        provider.on("pending", async (txHash) => {
            if (lastSuspectedReentrancy === txHash) {
                return;
            }
            lastSuspectedReentrancy = txHash;
            const txData = await provider.getTransaction(txHash);

            // remove 0x from CONTRACT_ADDRESS
            const contractAddress = config.CONTRACT_ADDRESS.substring(2).toLowerCase();

            // check txData and check if CONTRACT address is included in the string
            const vulContractInteraction = txData.data.includes(contractAddress)
            if (!vulContractInteraction) return;

            // Checking Reentrancy Pattern, Refer - notification_microservice/src/service/watcher.js
            const contractBalance = await provider.getBalance(config.CONTRACT_ADDRESS);
            const isContract = await provider.getCode(txData.to);
            const gasLimit = txData.gasLimit.toString();
            const amount = txData.value;

            const isReentrancySuspect = isContract !== "0x" && amount > (BigInt(contractBalance) / BigInt(3)) && gasLimit > 65000

            if (isReentrancySuspect) {
                console.warn("ATTACK SUSPECTED: Reentrancy suspected");
                updateDatabase(config.STORAGE_API_URL + "/pausingTx", {
                    attacker: txData.from,
                    attackTxId: txHash
                },
                    "new pausing transaction")

                // send a front running transaction 
                pauseTransaction(txData, txHash);
            }
        })
    } catch (error) {
        console.error("Error watching contract:", error);
    }
}

const pauseTransaction = async (txData, txHash) => {
    try {
        const providedGasPrice = txData.gasPrice;
        const nonce = txData.nonce;
        const gasFeeData = await provider.getFeeData(); // get current gas price 
        const gasPrice = gasFeeData.gasPrice;
        const increasedGasPrice = BigInt(gasPrice) * BigInt(2); // double the price

        // check if this price is greater than provideGasPrice
        const newGasPrice = providedGasPrice > increasedGasPrice ?
            BigInt(10000) + BigInt(providedGasPrice) : increasedGasPrice;

        console.log("Attempting to block the transaction......");
        const tx = await contract.pause({
            gasPrice: newGasPrice,
            nonce: nonce,
        })
        const txReceipt = await tx.wait();
        const blockNumber = txReceipt.blockNumber;
        const transactionHash = txReceipt.transactionHash;
        console.log(`succefully blocked attack transaction with hash: ${txReceipt.hash}`);
        // update database
        updateDatabase(config.STORAGE_API_URL + "/pausingTx/attackTx/" + txHash,
            {
                blockNumber,
                status: "paused",
                firstRunTxId: transactionHash,
                sucess: true
            },
            "pausing transaction success"
        )
    } catch (error) {
        updateDatabase(config.STORAGE_API_URL + "/pausingTx/attackTx/" + txHash,
            {
                status: "failed",
                sucess: false
            },
            "pausing transaction failure")
        console.error("Error blocking transaction:", error);
    }
}

const updateDatabase = async (url, data, message = "") => {
    axios.put(url, data).then(() => {
        console.log(`Successfully Updated Database: ${message}`)
    }).catch(error =>
        console.error("Error updating database:", error)
    )
}


export default {
    watchAndPause
}