import { ethers } from "ethers";
import config from "@/config";
import axios from "axios";

const contractJSON = require('@/abi/Deposit_V1.json') // Vulnerable smartcontract
const provider = new ethers.InfuraWebSocketProvider(config.NETWORK, config.INFURA_API_KEY);
const wallet = ethers.Wallet.fromPhrase(config.MNEMONIC, provider);
const contract = new ethers.Contract(config.CONTRACT_ADDRESS, contractJSON.abi, wallet);

const watchAndPause = async () => {
    try {
        contract.on("reentrancy", async (attacker, event) => {
            try {
                /**
                 * REENTRANCY CONFIRMED
                 * *********************
                 * This event is emiited when a reentrancy attack is confirmed.
                 * This event is triggered by the reentrancy modifier, inspired.
                 * from oppenzepplin reentrancyGuard.
                 * *********************
                 */

                // getting data from event log
                const txHash = event?.log?.transactionHash;
                const txData = await provider.getTransaction(txHash);
                const providedGasPrice = txData.gasPrice;
                const nonce = txData.nonce;

                // send a new transaction with updated gas price to 

                console.warn("ATTACK DETECTED: Reentrancy confirmed");
                console.log(`attacker: ${attacker}`);
                console.log(`txHash: ${txHash}`);

                // create pauseTx object in database (using storage microservice)
                let pauseTx;
                axios.post(config.STORAGE_API_URL + "/pausingTx", {
                    attacker: attacker,
                    attackTxId: txHash
                }).then((res) => {
                    pauseTx = res.data;
                    console.log("Successfully Created PauseTx Object in Database..")
                }).catch(error =>
                    console.error("Error updating database:", error)
                )

                // send a front running transaction 
                const gasPrice = await provider.getGasPrice(); // get current gas price 
                const increasedGasPrice = gasPrice.mul(ethers.BigNumber.from(2)); // double the price

                // check if this price is greater than provideGasPrice
                const newGasPrice = providedGasPrice.gt(increasedGasPrice) ?
                    ethers.BigNumber.from(10000).add(ethers.BigNumber.from(providedGasPrice)) : increasedGasPrice;

                console.log("Attempting to block the transaction......");
                const tx = await contract.pause({
                    gasPrice: newGasPrice,
                    nonce: nonce,
                })
                try {
                    const txReceipt = await tx.wait();
                    console.log(`succefully blocked the transaction with hash: ${txReceipt.transactionHash}`);
                    // update database
                    axios.put(config.STORAGE_API_URL + "/pausingTx/" + pauseTx._id, {
                        blockNumber: txReceipt.blockNumber,
                        status: "paused",
                        firstRunTxId: txReceipt.transactionHash,
                        sucess: true
                    }).then((res) => {
                        console.log("Successfully Updated Databse..")
                    }).catch(error =>
                        console.error("Error updating database:", error)
                    )
                } catch (error) {
                    // update failure
                    axios.put(config.STORAGE_API_URL + "/pausingTx/" + pauseTx._id, {
                        status: "failed",
                    }).then((res) => {
                        console.log("Successfully Updated Databse..")
                    }).catch(error =>
                        console.error("Error updating database:", error)
                    )
                    console.error("Error blocking transaction:", error);
                }


            } catch (error) {
                console.error("Error handling reentrancy event:", error);
            }
        })
    } catch (error) {
        console.error("Error watching contract:", error);
    }
}

export default {
    watchAndPause
}