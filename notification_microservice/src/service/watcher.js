import { ethers } from "ethers";
import mailService from "@/service/mailer";
import config from "@/config";

const contractJSON = require('@/abi/Deposit_V1.json') // Vulnerable smartcontract
const provider = new ethers.InfuraWebSocketProvider(config.NETWORK, config.INFURA_API_KEY);
//const provider = new ethers.WebSocketProvider("http://127.0.0.1:8545", config.NETWORK);
const contract = new ethers.Contract(config.CONTRACT_ADDRESS, contractJSON.abi, provider);
let lastConfirmedReentrancy = "0x0"; // prevent re-firing of withdraw event
let lastSuspectedReentrancy = "0x0"  // prevent re-firing of reentrancy event


const watch = async () => {
    try {
        contract.on("withdwal", async (withdrawer, amount, event) => {
            try {

                // getting data from event log
                const txHash = event?.log?.transactionHash;
                if (lastSuspectedReentrancy === txHash) {
                    return;
                }
                lastSuspectedReentrancy = txHash;
                console.log(`new withdrawal from ${withdrawer} with amount ${amount} detected; Checking for Reentrancy......`)
                //get transaction info from tx hash
                const txData = await provider.getTransaction(txHash);
                const txReceipt = await provider.getTransactionReceipt(txHash);
                const contractBalance = await provider.getBalance(config.CONTRACT_ADDRESS);

                /**
                 * CHECKING FOR REENTRANCY PATTERN
                 * *******************************
                 * Following steps are carried out to check and suspect Reentrancy Attack.
                 * 
                 * * Check if the withdrawer is a contract address.
                 * * Check if the amount transfered more than 1/3 of contract balance.
                 * * Check if the gasLimit is more than 65000
                 * * Check if the gasUsed (after confirmation) is greater than 55000
                 * 
                 * ********************************
                 * More Complicated detection can include balance verification.
                 * For a genuine transaction the difference between contracts Ether balnce
                 * and total balance of accounts (stored in contract using mapping) will same
                 * before and after transaction. {NOT IMPLIMENTED}
                 */

                const isContract = await provider.getCode(withdrawer);
                const gasLimit = txData.gasLimit.toString();
                const gasUsed = txReceipt.gasUsed.toString();

                const isReentrancySuspect = isContract !== "0x" && amount > (BigInt(contractBalance) / BigInt(3)) && gasLimit > 65000 && gasUsed > 55000;

                if (isReentrancySuspect) {
                    console.warn("ATTACK DETECTED: Reentrancy suspected");
                    console.log(`txHash: ${txHash}`);
                    console.log(`withdrawer: ${withdrawer}`);
                    console.log(`amount: ${amount.toString()}`);
                    console.log(`gasLimit: ${gasLimit}`);
                    console.log(`gasUsed: ${gasUsed}`);
                    console.log(`contractBalance: ${contractBalance.toString()}`);
                    console.log(`isContract: ${isContract !== "0x"}`);
                    console.log('Sending Email....')
                    mailService.sendMail(config.MAIL_ADMIN, "Reentrancy Attack Suspected", `
                        <p>A potential Reentrancy attack has been detected on the contract ${config.CONTRACT_ADDRESS}.</p>
                        <p>The attacker is ${withdrawer} and the amount withdrawn is ${amount.toString()}.</p>
                        <p>The transaction hash is ${txHash}.</p>
                        <p>Please investigate this transaction.</p>
                    `);
                }
            } catch (error) {
                console.error("Error handling withdrawal event:", error);
            }
        })

        contract.on("reentrancy", (attacker, event) => {
            try {
                /**
                 * REENTRANCY CONFIRMED
                 * *********************
                 * This event is emiited when a reentrancy attack is confirmed.
                 * This event is triggered by the reentrancy modifier, inspired.
                 * from oppenzepplin reentrancyGuard.
                 * *********************
                 */

                // getting data from event log
                const txHash = event?.log?.transactionHash;
                if (lastConfirmedReentrancy === txHash) {
                    return;
                }
                lastConfirmedReentrancy = txHash;
                console.warn("ATTACK DETECTED: Reentrancy confirmed");
                console.log(`attacker: ${attacker}`);
                console.log(`txHash: ${txHash}`);
                console.log('Sending Email....')
                mailService.sendMail(config.MAIL_ADMIN, "Reentrancy Attack Detected", `
                        <p>A Reentrancy attack has been detected on the contract ${config.CONTRACT_ADDRESS}.</p>
                        <p>The attacker is ${attacker}.</p>
                        <p>The transaction hash is ${txHash}.</p>
                        <p>Please investigate this transaction.</p>
                    `);
            } catch (error) {
                console.error("Error handling reentrancy event:", error);
            }
        })
    } catch (error) {
        console.error("Error watching contract:", error);
    }
}

export default {
    watch
}