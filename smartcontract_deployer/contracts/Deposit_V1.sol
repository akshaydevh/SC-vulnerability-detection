// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

// Uncomment this line to use console.log
// import "hardhat/console.sol";

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";

contract Deposit_V1 is
    Initializable,
    UUPSUpgradeable,
    OwnableUpgradeable,
    PausableUpgradeable
{
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    /**
     * @dev this mapping stores all balances.
     */
    mapping(address => uint256) public balances;

    /**
     * Emitted when a reentrancy attack detected.
     */
    event reentrancy(address indexed attacker);

    // prevent intialization of logic contract.
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @dev initialize the contract.
     * setting msg sender as owner.
     * Note:initializer modifier is used to prevent initialization of contract twice.
     */
    function __Deposit_V1_init() public initializer {
        __UUPSUpgradeable_init();
        __Ownable_init(_msgSender());
        __Pausable_init();
        _status = _NOT_ENTERED;
    }

    /**
     * @dev allows deposit of ETH to the contract.
     * deposited value will be added to the contract balance
     *
     * Requirements:
     * - contract not paused.
     */
    function deposit() public payable whenNotPaused virtual{
        balances[_msgSender()] += msg.value;
    }

    /**
     * @dev This function allows withdrawal of ETH from the contract.
     * @param amount - amount wish to withdraw.
     * Requirements:
     *  - amount should be less than or equal to balance.
     * Note
     *  - This function is vulnerable to a reentrancy attack.
     *    The interaction occurs before the state changes,
     *    allowing a malicious actor to re-enter the function before the balance is updated,
     *    potentially exhausting the contractâ€™s balance.
     */
    function withdraw(
        uint256 amount
    ) public whenNotPaused checkAndEmitReentrancy virtual {
        require(balances[_msgSender()] >= amount, "Insufficient balance");
        (bool success, ) = _msgSender().call{value: amount}(""); // transfering fund
        require(success, "Transfer failed");
        // from soldity version 0.8.0 overflow check is added.
        // disable overflow check by making the line unchecked.
        unchecked {
            balances[_msgSender()] -= amount; // updating contract state
        }
    }

    /**
     * @dev This is required by OPZEP UUPS to avoid un-authorized access.
     * See {UUPSUpgradeable}
     */
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyOwner {}

    /**
     * @dev Pauses the contract.
     * See {PausableUpgradeable} and {_pause}.
     * Requirements:
     *  - the caller must be the owner of the contract.
     */
    function pause() public onlyOwner {
        _pause();
    }

    /**
     * @dev Unpauses the contract.
     * See {PausableUpgradeable} and {_unpause}.
     * Requirements:
     *  - the caller must be the owner of the contract.
     */
    function unpause() public onlyOwner {
        _unpause();
    }

    /**
     * @dev This function modifier helps to detect Reentrancy
     *      and emit an event with attacker's address.
     */
    modifier checkAndEmitReentrancy() {
        if (_status != _ENTERED) {
            emit reentrancy(_msgSender());
        }
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}
